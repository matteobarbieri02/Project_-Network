---
title: "project 2"
author: "bonatti, barbieri"
date: "2024-06-04"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(igraph)
library(readr)
# install.packages("ergm")
```

Percorsi:

- Matte : C:/Users/bmatt/Desktop/UNICATT/Corsi/NETWORK DATA/trade-2021-flows.csv
- Lollo: C:/Users/loren/Downloads/trade-2021-flows.csv

```{r}
data <- read.csv("C:/Users/loren/Downloads/trade-2021-flows.csv", sep = "",header = T)

str(data)
head(data)
```


```{r}
# Estrai un elenco unico di paesi presenti nei dati
nodes <- unique(c(data$from, data$to))

# Crea un dataframe per i nodi
nodes_df <- data.frame(id = nodes)

# Crea un dataframe per i link
links_df <- data[, c("from", "to")]

# Rinomina le colonne per essere coerenti con gli standard di network analysis
colnames(links_df) <- c("source", "target")

# Visualizza i primi pochi nodi e link
head(nodes_df)
head(links_df)

nrow(links_df)
table(is.na(links_df))
```

In order to see if there are duplicate interactions between characters, I create a new dataframe from the links one and group by the source and target columns. If they occur, I will count them.

```{r}
multiple_int <- links_df %>%
  group_by(source, target) %>%
  summarize(n = n()) %>%
  group_by(source, target) %>%
  filter(n > 1)

head(multiple_int)
```


```{r}
g  <- graph_from_data_frame(links_df, directed = FALSE)
#check if the graph is connected
is_connected(g)
```
```{r}
#check if the graph is simple
is_simple(g)
```
In matematica e teoria dei grafi, un grafo semplice è un grafo che non contiene né cicli multipli (cicli con ripetizioni di vertici) né più archi tra gli stessi nodi.

```{r}
max(data$amount)

max_amount <- max(data$amount)

# Passo 2: Filtrare il dataset per trovare la riga con l'importo massimo
max_transaction <- data[data$amount == max_amount, ]

# Passo 3: Estrarre i paesi coinvolti
#countries_involved <- max_transaction[, c("country1", "country2")]

# Stampa i risultati
print(max_transaction)


g_w <- graph_from_data_frame(links_df, directed = FALSE)


E(g_w)

#setting weights
E(g_w)$weight <- data$amount 

g_w

help(E)
head(E(g_w)$weight)

summary(E(g_w)$weight)

# check min
min_amount <- min(data$amount)

# Passo 2: Filtrare il dataset per trovare la riga con l'importo massimo
min_transaction <- data[data$amount == min_amount, ]
```

plot

```{r}
hist(E(g_w)$weight, breaks = 25,
     xlab= "Weights", main="Edges' Weight Distribution", col = 'lightblue', border = 'white', ylim=c(0,1000), xlim = c(6.361e+05, 3.861e+11 ))

```
Assicurati che la colonna "amount" nel tuo dataframe contenga i valori dei pesi degli archi. Una volta assegnati correttamente i pesi, dovresti essere in grado di visualizzare il grafo con i pesi sugli archi.



```{r}
head(table(E(g_w)$weight))
```
Per ciascun peso elencato (636141, 688352, 743114, 1018557, 1418345, 1601447), il valore di frequenza è 1. Questo significa che ciascuno di questi pesi appare una sola volta tra gli archi del grafo g_w.

```{r}
library(visNetwork)

vis_g <- toVisNetworkData(g)


visNetwork(
  nodes = vis_g$nodes,
  edges = vis_g$edges,
  width = "100%",
  height = '500px'
)

```
```{r}
vis_g_w <- toVisNetworkData(g_w)

visNetwork(
  nodes = vis_g_w$nodes,
  edges = vis_g_w$edges,
  width = "100%",
  height = '500px'
)
```

## Degree analysis 

```{r}
table(degree(g_w))
```

Ci sono 2 nodi con un grado di 32.
Ci sono 7 nodi con un grado di 33.
C'è 1 nodo con un grado di 70.
Ci sono 3 nodi con un grado di 71.
Ci sono 7 nodi con un grado di 72.
Ci sono 22 nodi con un grado di 73.


```{r}
hist(degree(g_w), breaks = 50, ylim = c(0,25), xlim=c(25,75), col = 'darkorange',
     xlab= "Degree",main = "Degree")

```

```{r}
degree_dist <- function(graph) {
  fd <- table(degree(graph))
  d <- as.numeric(names(fd)) + 1 
  list(d = d, fd = fd)
}

dd <- degree_dist(g_w)

with(dd, plot(d, fd, main="Degree Distribution", xlab="Degree", ylab="Frequency of each Degree", pch=16, col='blue', ylim = c(0,30), xlim = c(0, 100)))
```
## transitivity

Transitivity measures the tendency of nodes to cluster together.
```{r}
t <- transitivity(g_w)
t
```
There is an high level of clustering in our data.


## Strength

Strength is particularly significant when talking about weighted graphs, since it quantifies the cumulative weight of all the edges connected to a certain node, and so the importance of connections that the node has in the network.
```{r}
s <- graph.strength(g_w)
summary(s)
hist(s, breaks = 30, ylim = c(0,15), xlim=c(1.160e+10 ,2.984e+12 ), main= "Histogram of Strength",
     xlab= "Strength", col='#FF6666')

max(s)
s

max_country <- names(which.max(s))
min_country <- names(which.min(s))

# Valori corrispondenti
max_value <- max(s)
min_value <- min(s)

# Stampa dei risultati
cat("Il paese con il valore massimo è:", max_country, "con un valore di", max_value, "\n")
cat("Il paese con il valore minimo è:", min_country, "con un valore di", min_value, "\n")
```

## Betweenness

```{r}
b <- betweenness(g_w)
hist(b, breaks = 40, main= "Histogram of Betweenness", xlim=c(0, 150), ylim= c(0,70),
     xlab= "Betweenness", col=hcl.colors(length(b), rev = F, palette= 'blues'))
```
```{r}
b
```
From this analysis, it can be observed that small countries play a crucial role as intermediaries, which is why they have high betweenness centrality values. For example, if Estonia and Slovenia are important nodes for specific trade flows (such as technology or particular materials), they may appear central in those contexts.

At the same time, many countries, such as AUS, AUT, BEL, CAN, etc., have a betweenness centrality of 0. This means that these countries are not on the shortest paths between other countries in the trade network.

Positive values: Some countries have positive betweenness centrality values, indicated below:
CHL (3): Chile has a betweenness centrality of 3.
FIN (116): Finland has a betweenness centrality of 116.
ISL (752): Iceland has a betweenness centrality of 752, which suggests that Iceland is a very important node in the network, as many shortest paths pass through it.
JPN (40): Japan has a betweenness centrality of 40.
NZL (254): New Zealand has a betweenness centrality of 254.
SVN (79): Slovenia has a betweenness centrality of 79.

Countries like Iceland (ISL), New Zealand (NZL), Finland (FIN), Japan (JPN), and Slovenia (SVN) have significant influence on the trade network. Many shorter trade paths pass through these countries. Countries with a betweenness centrality of 0 do not have a central role in the shortest trade paths. They can be considered peripheral or isolated in the network relative to the most efficient paths.

Betweenness centrality is a useful indicator for identifying crucial nodes in a network that facilitate the flow of information or goods. In a trade network, countries with high betweenness centrality may be crucial for global trade, acting as intermediaries or hubs through which many trade routes pass.

```{r}
plot(s, b, ylab="Betweenness", xlab= "Strength", main= "Betweenness vs Strength", pch=16, col=hcl.colors(length(b), rev = F, palette= 'blues'))
```
Relationship between nodes’ strength and betweenness measures. In this case I can see that there are very few observations that have high values in both centrality measures. Therefore one of these points could be the “important countries” in our network.
We can also observe that apparently countries with higher betweenness tend to have lower strength.

## Important countries

```{r}
most_index <- names(which.max(b))

most_index

names(which.max(s))

```

## Network Modelling

### ERGM model

```{r}
library(ergm)
am <- get.adjacency(g_w, sparse = FALSE)
g_ergm <-as.network(am, directed = FALSE)
ergm(g_ergm~edges) %>% summary
```

 - Estimate: The value here, 3.0754, indicates a positive effect of edges on the likelihood of edges forming. In simpler terms, the more edges exist in the network, the more likely it is for additional edges to appear.


## Clustering

### Fast Greedy Algorithm

This algorithm starts with a subnetwork composed only of highly connected nodes, then iteratively merges communities that result in the maximum increase in modularity; this is a measure that quantifies the quality of a partition of a network into communities. It compares the number of edges within communities to the expected number of edges in a random network with the same degree distribution.

```{r}
# use simplify because we have multiedges graph
g_kc <- simplify(g_w)
kc <- cluster_fast_greedy(g_kc)
l_kc <- length(kc)
cat('The number of clusters by the Fast Greedy Algorithm are:',l_kc,'\n')
```

```{r}
table(membership(kc))
```

```{r}
set.seed(1234)

V(g_kc)$community <- kc$membership

colors <- adjustcolor(col = c("red", "violet"), alpha=1)

plot(kc, g_kc, vertex.size=5, , vertex.color=colors[V(g_kc)$community], vertex.label=NA, asp=.5, main="Fast Greedy Clustering")
```

Below we plotted the dendrogram.

```{r}
dend_col <- c("red", "violet")
par(cex=.4)
plot_dendrogram(kc, mode = 'hclust', colbar=dend_col, axes=FALSE)
legend("topright", legend=c(1:length(kc)), col=dend_col, lwd=2)
```

Especially from the dendrogram it is possible to denote that the 2 clusters obtained are divided in his way:

- Cluster 1: American and pacific countries
- Clsuter 2: European countries

We calculate the modularity score for the fast greedy clustering algorithm, to understand how well the method is able to divide the network into clusters.

```{r}
mod_kc <- modularity(kc)
cat('The Modularity Coefficient is:',mod_kc,'\n')
```


### Louvain clustering

**Algorithm Type**:

 - Louvain clustering is a modularity-based optimization method.

**Mechanism**:

The algorithm starts with each node in its own community.
It iteratively merges communities in a way that maximizes the modularity score, which measures the density of links inside communities compared to links between communities.

It performs a two-phase process:
 - Local Moving: Nodes are moved between communities to optimize modularity.
 - Aggregation: Communities are aggregated into a single node and the process is repeated.

downsides of the method: It may not detect small or loosely connected communities effectively if they do not significantly increase modularity.

This method uses the concept of betweenness centrality. It identifies communities by iteratively removing edges with the highest betweenness centrality.

```{r}
set.seed(20141)
g_la <- g_w
louvain <- cluster_louvain(g_la) 
```

```{r}
l_cla <- length(louvain)
cat('The number of clusters by Edge Betweenness Algorithm are:',l_cla,'\n')
```


```{r}
plot(louvain, g_la, vertex.size=5, vertex.label=NA, asp=.5, main="Louvain Clustering")
```


```{r}
table(membership(louvain))
```
```{r}
membership_info <- membership(louvain)

# Create a table of memberships
membership_table <- table(membership_info)

vertex_names <- V(g_la)$name


cluster1_nodes <- vertex_names[membership_info == 1]
cluster2_nodes <- vertex_names[membership_info == 2]

# Print the countries in each cluster
cat("Countries in Cluster 1:\n")
print(cluster1_nodes)

cat("Countries in Cluster 2:\n")
print(cluster2_nodes)

```


We calculate the modularity score also for the Louvain algorithm, to understand how well the method is able to divide the network into clusters.

```{r}
mod_la <- modularity(louvain)
cat('The modularity Coefficient is:',mod_la,'\n')
```

## Cluster by Edge Betweeness

Cluster by edge betweenness, also known as the Girvan-Newman algorithm, is a method used in network analysis to identify community structure within a network. The basic idea is to iteratively remove edges from the network that have the highest betweenness, which often lie between different communities, until the network is divided into distinct clusters. 

**Algorithm Type**:

 - Edge Betweenness clustering is based on the concept of edge **betweenness centrality**.

**Mechanism**:

Edge betweenness centrality measures the number of shortest paths that pass through each edge.
The algorithm removes edges with the highest betweenness centrality, which are considered to be "bridges" between communities.
This process is repeated iteratively, recalculating betweenness after each removal, until the network is fragmented into desired communities.

Edge Betweenness can identify small or weakly connected communities but is computationally expensive.


```{r}
set.seed(20141)
g_ceb <- g_w
ceb <- cluster_edge_betweenness(g_ceb)
```
```{r}
l_ceb <- length(ceb)
cat('The number of clusters by Edge Betweenness Algorithm are:',l_ceb,'\n')
```
```{r}
mod_ceb <- modularity(ceb)
cat('The Modularity Coefficient is:',mod_ceb,'\n')
```
This suggests that the algorithm did not identify any meaningful community structure within the network. In other words, the network remains as a single connected component without breaking down into smaller, distinct clusters.

This could happen because the network could be highly connected, with most nodes being directly or indirectly connected to each other through multiple pathways, making it difficult for the algorithm to find edges that significantly increase modularity when removed.

## Modularity Scores table

```{r}
mod_tab <- cbind(mod_kc, mod_ceb, mod_la)
mod_tab
```

Louvain algorithm and Fast Greedy clustering have very similar modularity score. This means that there is no particular difference in how well the methods divide the network into communities, in fact they both suggest 2 clusters with similar size. 
Instead, as we have seen previusly, Cluster by edge betweenness has a modularity core equal to 0 because it was not able to detect any community inside the network.



## Subgraphing

### Assigning nodes membership

```{r}
cluster_df <- data.frame(as.list(membership(kc)))
cluster_df <- as.data.frame(t(cluster_df))
cluster_df$id <- rownames(cluster_df)

cluster_df$id <- gsub("X", "", cluster_df$id)
rownames(cluster_df) <- gsub("X", "", rownames(cluster_df))

nodes_df$id <- rownames(nodes_df)

cluster_nodes <- merge(cluster_df, nodes_df, by = "id", all.x = TRUE)
cluster_nodes <- rename(cluster_nodes, "cluster" = "V1")
```

```{r}

colnames(links_df)<-c("from", "to")

visNetwork(cluster_nodes, links_df, width = "100%") %>%
  visIgraphLayout() %>%
  visNodes(
    shape = "dot",
    color = list(
      background = "#0085AF",
      border = "#013848",
      highlight = "#FF8000"
    ),
    shadow = list(enabled = TRUE, size = 10)
  ) %>%
  visEdges(
    shadow = FALSE,
    color = list(color = "#0085AF", highlight = "#C62F4B")
  ) %>%
  visOptions(highlightNearest = list(enabled = T, degree = 1, hover = T),
             selectedBy = "cluster") %>% 
  visLayout(randomSeed = 11)
```


```{r}
links_2 <- links_df

links_2$id <- links_2$from

prova_merge <- merge(links_2, cluster_nodes, by="id", all.x=TRUE)
head(prova_merge)
```

