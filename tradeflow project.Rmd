---
title: "project 2"
author: "bonatti, barbieri"
date: "2024-06-04"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(igraph)
library(readr)
```


```{r}
data <- read.csv("C:/Users/loren/Downloads/trade-2021-flows.csv", sep = "",header = T)

str(data)
head(data)
```


```{r}
# Estrai un elenco unico di paesi presenti nei dati
nodes <- unique(c(data$from, data$to))

# Crea un dataframe per i nodi
nodes_df <- data.frame(id = nodes)

# Crea un dataframe per i link
links_df <- data[, c("from", "to")]

# Rinomina le colonne per essere coerenti con gli standard di network analysis
colnames(links_df) <- c("source", "target")

# Visualizza i primi pochi nodi e link
head(nodes_df)
head(links_df)

nrow(links_df)
table(is.na(links_df))
```

In order to see if there are duplicate interactions between characters, I create a new dataframe from the links one and group by the source and target columns. If they occur, I will count them.

```{r}
multiple_int <- links_df %>%
  group_by(source, target) %>%
  summarize(n = n()) %>%
  group_by(source, target) %>%
  filter(n > 1)

head(multiple_int)
```


```{r}
g  <- graph_from_data_frame(links_df, directed = FALSE)
#check if the graph is connected
is_connected(g)
```
```{r}
#check if the graph is simple
is_simple(g)
```
In matematica e teoria dei grafi, un grafo semplice è un grafo che non contiene né cicli multipli (cicli con ripetizioni di vertici) né più archi tra gli stessi nodi.

```{r}
max(data$amount)

max_amount <- max(data$amount)

# Passo 2: Filtrare il dataset per trovare la riga con l'importo massimo
max_transaction <- data[data$amount == max_amount, ]

# Passo 3: Estrarre i paesi coinvolti
#countries_involved <- max_transaction[, c("country1", "country2")]

# Stampa i risultati
print(max_transaction)


g_w <- graph_from_data_frame(links_df, directed = FALSE)


E(g_w)
#setting weights
E(g_w)$weight <- data$amount 

g_w

help(E)
head(E(g_w)$weight)

summary(E(g_w)$weight)

# check min
min_amount <- min(data$amount)

# Passo 2: Filtrare il dataset per trovare la riga con l'importo massimo
min_transaction <- data[data$amount == min_amount, ]
```

plot

```{r}
hist(E(g_w)$weight, breaks = 25,
     xlab= "Weights", main="Edges' Weight Distribution", col = 'lightblue', border = 'white', ylim=c(0,1000), xlim = c(6.361e+05, 3.861e+11 ))

```
Assicurati che la colonna "amount" nel tuo dataframe contenga i valori dei pesi degli archi. Una volta assegnati correttamente i pesi, dovresti essere in grado di visualizzare il grafo con i pesi sugli archi.



```{r}
head(table(E(g_w)$weight))
```
Per ciascun peso elencato (636141, 688352, 743114, 1018557, 1418345, 1601447), il valore di frequenza è 1. Questo significa che ciascuno di questi pesi appare una sola volta tra gli archi del grafo g_w.

```{r}
library(visNetwork)

vis_g <- toVisNetworkData(g)


visNetwork(
  nodes = vis_g$nodes,
  edges = vis_g$edges,
  width = "100%",
  height = '500px'
)

```
```{r}
vis_g_w <- toVisNetworkData(g_w)

visNetwork(
  nodes = vis_g_w$nodes,
  edges = vis_g_w$edges,
  width = "100%",
  height = '500px'
)
```



## analysis 

```{r}
table(degree(g_w))
```

Ci sono 2 nodi con un grado di 32.
Ci sono 7 nodi con un grado di 33.
C'è 1 nodo con un grado di 70.
Ci sono 3 nodi con un grado di 71.
Ci sono 7 nodi con un grado di 72.
Ci sono 22 nodi con un grado di 73.


```{r}
hist(degree(g_w), breaks = 50, ylim = c(0,25), xlim=c(25,75), col = 'darkorange',
     xlab= "Degree",main = "Degree")

```

```{r}
degree_dist <- function(graph) {
  fd <- table(degree(graph))
  d <- as.numeric(names(fd)) + 1 
  list(d = d, fd = fd)
}

dd <- degree_dist(g_w)

with(dd, plot(log(d), log(fd), main="Degree Distribution", xlab="Degree", ylab="Frequency of each Degree", pch=16, col='blue'))
```
## transitivity

Transitivity measures the tendency of nodes to cluster together.
```{r}
t <- transitivity(g_w)
t
```
there is an high level of clustering in our data.

## strenght

Strength is particularly significant when talking about weighted graphs, since it quantifies the cumulative weight of all the edges connected to a certain node, and so the importance of connections that the node has in the network.
```{r}
s <- graph.strength(g_w)
summary(s)
hist(s, breaks = 30, ylim = c(0,15), xlim=c(1.160e+10 ,2.984e+12 ), main= "Histogram of Strength",
     xlab= "Strength", col='#FF6666')

max(s)
s

max_country <- names(which.max(s))
min_country <- names(which.min(s))

# Valori corrispondenti
max_value <- max(s)
min_value <- min(s)

# Stampa dei risultati
cat("Il paese con il valore massimo è:", max_country, "con un valore di", max_value, "\n")
cat("Il paese con il valore minimo è:", min_country, "con un valore di", min_value, "\n")
```

## betweenness

```{r}
b <- betweenness(g_w)
hist(b, breaks = 40, main= "Histogram of Betweenness", xlim=c(0, 150), ylim= c(0,70),
     xlab= "Betweenness", col=hcl.colors(length(b), rev = F, palette= 'blues'))
```
```{r}
b
```
Se il dataset rappresenta specifici tipi di commercio o settori economici in cui questi piccoli paesi giocano un ruolo cruciale come intermediari, allora è possibile che abbiano valori di betweenness centrality elevati. Ad esempio, se Estonia e Slovenia sono nodi importanti per certi flussi commerciali specifici (come tecnologia o materiali particolari), potrebbero apparire centrali in quei contesti.


valore di betweenness centrality pari a 0: Molti paesi, come AUS, AUT, BEL, CAN, etc., hanno una betweenness centrality di 0. Questo significa che questi paesi non si trovano sui percorsi più brevi tra altri paesi nella rete commerciale.
Valori positivi: Alcuni paesi hanno valori positivi di betweenness centrality, indicati di seguito:
CHL (3): Cile ha una betweenness centrality di 3.
FIN (116): Finlandia ha una betweenness centrality di 116.
ISL (752): Islanda ha una betweenness centrality di 752, il che suggerisce che Islanda è un nodo molto importante nella rete, dato che molti percorsi più brevi passano attraverso di essa.
JPN (40): Giappone ha una betweenness centrality di 40.
NZL (254): Nuova Zelanda ha una betweenness centrality di 254.
SVN (79): Slovenia ha una betweenness centrality di 79.
Analisi:
Importanza nella rete: Paesi come Islanda (ISL), Nuova Zelanda (NZL), Finlandia (FIN), Giappone (JPN), e Slovenia (SVN) hanno un'influenza significativa sulla rete commerciale. Molti percorsi commerciali più brevi passano attraverso questi paesi.
Isolamento o periferia: Paesi con betweenness centrality pari a 0 non hanno un ruolo centrale nei percorsi commerciali più brevi. Possono essere considerati periferici o isolati nella rete rispetto ai percorsi più efficienti.
Ha senso?
Sì, ha senso interpretare i valori di betweenness centrality in questo modo. La betweenness centrality è un indicatore utile per identificare i nodi cruciali in una rete che facilitano il flusso di informazioni o beni. In una rete commerciale, i paesi con alta betweenness centrality potrebbero essere cruciali per il commercio globale, agendo come intermediari o hub attraverso cui passano molte rotte commerciali.

```{r}
plot(s, b, ylab="Betweenness", xlab= "Strength", main= "Betweenness vs Strength", pch=16, col=hcl.colors(length(b), rev = F, palette= 'blues'))
```
relationship between nodes’ strength and betweenness measures. In this case I can see that there are very few observations that have high values in both centrality measures. Therefore one of these points could be the “important character” in our network.

## important countries

```{r}
most_index <- names(which.max(b))

most_index

names(which.max(s))

```

```{r}
library(ergm)
am <- get.adjacency(g_w, sparse = FALSE)
g_ergm <-as.network(am, directed = FALSE)
ergm(g_ergm~edges) %>% summary
```

 - Estimate: The value here, 3.0754, indicates a positive effect of edges on the likelihood of edges forming. In simpler terms, the more edges exist in the network, the more likely it is for additional edges to appear.


## Cluster Fast Greedy Algorithm

This algorithm starts with a subnetwork composed only of highly connected nodes, then iteratively merges communities that result in the maximum increase in modularity; this is a measure that quantifies the quality of a partition of a network into communities. It compares the number of edges within communities to the expected number of edges in a random network with the same degree distribution.

```{r}
# use simplify because we have multiedges graph
g_kc <- simplify(g_w)
kc <- cluster_fast_greedy(g_kc)
l_kc <- length(kc)
cat('The number of clusters by the Fast Greedy Algorithm are:',l_kc,'\n')
```
```{r}
mod_kc <- modularity(kc)
cat('The Modularity Coefficient is:',mod_kc,'\n')
## The Modularity Coefficient is: 0.4550854
table(membership(kc))
```

```{r}
set.seed(1234)

V(g_kc)$community <- kc$membership

colors <- adjustcolor(col = c("red", "violet"), alpha=1)

plot(kc, g_kc, vertex.size=5, , vertex.color=colors[V(g_kc)$community], vertex.label=NA, asp=.5, main="Fast Greedy Clustering")
```
dendogram

```{r}
dend_col <- c("red", "violet")
par(cex=.4)
plot_dendrogram(kc, mode = 'hclust', colbar=dend_col, axes=FALSE)
legend("topright", legend=c(1:length(kc)), col=dend_col, lwd=2)
```
### clustering by betweenness

This method uses the concept of betweenness centrality. It identifies communities by iteratively removing edges with the highest betweenness centrality.

```{r}
g_ceb <- simplify(g_w)
ceb <- cluster_edge_betweenness(g_ceb) 
```

